length(height.dat)
#Make a histogram.
{hist(height.dat, freq=F, ylim=c(0,0.05), main='Distribution of the Height Data', xlab='Height (cm)',ylab='Density' )
hgt.mean = mean(bdims$hgt)
hgt.sd = sd(height.dat)
xseq = seq(from = min(bdims$hgt), to = max(height.dat), length = 100)
lines(y = dnorm(xseq, mean = hgt.mean, sd = hgt.sd), x = xseq, col = "blue")}
#Make a qqplot.
qqnorm(y = height.dat, main = "Normal Q-Q Plot for Height Data",
xlab = "Theoretical Quantiles", ylab = "Sample Quantiles", cex.lab = 0.8,
cex.main = 1.0)
qqline(y = height.dat, col = "blue")
#Store bdims data in df b.
b = bdims
#Make sex variable a factor.
b$sex = as.factor(bdims$sex)
# make sure that you convert the variable `sex` into a factor.
library(GGally)
library(ggplot2)
ggmatrix = function(b){
# make sure that you convert the variable `sex` into a factor.
b$sex = as.factor(bdims$sex)
ggpairs(b, title="Relationship between height and other variables in bdims, factored by sex", mapping=ggplot2::aes(color = sex), upper = list(continuous = wrap("cor", size = 1)), ylab = "Body masurements in cm", binwidth = 0.5) + theme(axis.text.x = element_text(size = 5), axis.text.y = element_text(size = 5))}
b = bdims[,c(1:5,24, 25)]
ggmatrix(b)
b = bdims[,c(6:10,24, 25)]
ggmatrix(b)
b = bdims[,c(11:15,24, 25)]
ggmatrix(b)
b = bdims[,c(15:20,24, 25)]
ggmatrix(b)
b = bdims[,(21:25)]
ggmatrix(b)
b=bdims
set.seed(8929)
set.index = sample(c('train', 'validation', 'test'), prob = c(.5, .25, .25), replace = T, size = nrow(b))
train = b[set.index == 'train', ]
valid = b[set.index == 'validation', ]
test = b[set.index == 'test', ]
dim(train)
dim(valid)
dim(test)
b=bdims
dim(b)
#Create empty vector to store the values in later.
v_errors = rep(NA, 27)
#Make a model.
samp.mod = lm(hgt ~ . + sex*bii.di + sex*che.de + sex*for.gi, data=b)
summary(samp.mod)
#Use the training set to make a model.
mod.1 = regsubsets(hgt ~ . + sex:bii.di + sex:che.de + sex:for.gi, data=train, nvmax=27)
summary.mod.1 = summary(mod.1)
#Store summary of best models in outmat.reg.
outmat.reg = as.data.frame(summary.mod.1$outmat)
v_errors
for(i in 1:27){
# Predict the y-values of the current fold with the
# "best" model with i predictors
MSE.mod.1 = predict.reg(mod.1, newdata = valid, id=i) #Fold==j, when j=1 then it takes the subset 1, etc.
#Basically saying i want the best model with i predictors! and im going to predict on the best validation data set
# Calculate the Mean Squared Error (MSE) estimate
# for the jth fold and best i-variable model, store it
# in the cv_errors matrix we created above
v_errors[i] = mean((valid$hgt-MSE.mod.1)^2)
}
v_errors
#Obtain the index number of which mean squared error (MSE) is the smallest.
min.1 = which.min(v_errors)[1]
min.1
#Plot the MSE
plot(v_errors, type='b', main="Mean Squared Error Values For Each Number of Predictors")
#Highlight the smallest one.
points(min.1, v_errors[min.1][1], col = "red", cex = 2, pch = 20)
#Indicate number of predictors as 12.
i=12
#Obtained predicted values with validation data set and linear model mod.1.
predict.hgt = predict.reg(object = mod.1, newdata = valid, id=i)
#Obtain MSE.
mse.hgt=mean((valid$hgt-predict.hgt)^2)
mse.hgt
#Indicate number of predictors as 12.
i=12
#Indicate id = i for function purposes.
id=i
#Combine training and validation data for refit step.
refit.dat=rbind(train,valid)
#Make a new model with training and validation data.
mod.1.refit = regsubsets(hgt ~ . + sex:bii.di + sex:che.de + sex:for.gi, data=refit.dat, nvmax=12)
#Summary of new model.
summary.mod.1.refit = summary(mod.1.refit)
#Obtain the coefficients from the champion model.
coefi.champ = as.data.frame(coef(mod.1.refit,id=id))
#Make into df.
coefi.champ.v = as.data.frame(t(coefi.champ))
#Change rownames.
rownames(coefi.champ.v) = c('coefficient.values')
coefi.champ.v
#Indicate number of predictors as 12.
i=12
#Obtained predicted values with test data set and adjusted linear model.
pred.refit = predict.reg(mod.1.refit, newdata = test, id=i)
#Obtain MSE.
mse.hgt.test=mean((test$hgt-pred.refit)^2)
mse.hgt.test
mse.hgt
mod.1 = regsubsets(hgt ~ . + sex:bii.di + sex:che.de + sex:for.gi, data=train, nvmax=27)
summary.mod.1 = summary(mod.1)
outmat.reg = as.data.frame(summary.mod.1$outmat)
v_errors
v_errors
min.1 = which.min(v_errors)[1]
min.1
plot(v_errors, type='b', main="Mean Squared Error Values For Each Number of Predictors")
Plot the MSE
```{r}
min.1 = which.min(v_errors)[1]
min.1
plot(v_errors, type='b', main="Mean Squared Error Values For Each Number of Predictors")
points(min.1, v_errors[min.1][1], col = "red", cex = 2, pch = 20)
plot(v_errors, type='b', main="Mean Squared Error Values For Each Number of Predictors")
#Highlight the smallest one.
points(min.1, v_errors[min.1][1], col = "red", cex = 2, pch = 20)
min.1 = which.min(v_errors)[1]
v_errors
min.1
min.1
v_errors
hgt
b=bdims
b
hgt
b
summary(samp.mod)
samp.mod
bdims
dim(b)
bdims
bdims
samp.mod
b
bdims
b
b$sex = as.factor(bdims$sex)
b = bdims
b$sex = as.factor(bdims$sex)
b
b=bdims
b
set.seed(8929)
set.index = sample(c('train', 'validation', 'test'), prob = c(.5, .25, .25), replace = T, size = nrow(b))
train = b[set.index == 'train', ]
valid = b[set.index == 'validation', ]
test = b[set.index == 'test', ]
b=bdims
dim(b)
v_errors = rep(NA, 27)
samp.mod = lm(hgt ~ . + sex*bii.di + sex*che.de + sex*for.gi, data=b)
summary(samp.mod)
samp.mod
b
b$sex = as.factor(bdims$sex)
samp.mod = lm(hgt ~ . + sex*bii.di + sex*che.de + sex*for.gi, data=b)
summary(samp.mod)
samp.mod = lm(hgt ~ . + sex*bii.di + sex*che.de + sex*for.gi, data=b)
summary(samp.mod)
source('~/Hawaii 2018:BIOS 2018/RAnalysis/Scripts/Vale_Daily.R')
source('~/Downloads/Tris.calib.R')
source('~/Hawaii 2018:BIOS 2018/RAnalysis/Scripts/Vale_Daily.R')
source('~/Hawaii 2018:BIOS 2018/RAnalysis/Scripts/Vale_Daily.R')
source('~/Hawaii 2018:BIOS 2018/RAnalysis/Scripts/Vale_Daily.R')
setwd("~/Hawaii 2018:BIOS 2018/RAnalysis/Data/20180617")
main<-getwd()
rm(list=ls())
setwd("/Users/hputnam/MyProjects/BioMin_HIS/RAnalysis/")
main<-getwd()
getwd()
setwd("~/Hawaii 2018:BIOS 2018/RAnalysis/Data")
main<-getwd()
main
source('~/MyProjects/BioMin_HIS/RAnalysis/Scripts/TotalAlkCalc_wParsing.R')
rm(list=ls())
main<-getwd()
library(seacarb) #used to calculate TA
library(tidyverse)
path<-"Data/20180617" #the location of all your titration files
massfile<-"20180617mass_Run2.csv" # name of your file with masses
titrationfile<-'20180617_Run2.csv'# name of the last titration file run
date<-'20180617'
Mass<-read.csv(file.path(path,massfile), header=T, sep=",", na.string="NA", as.is=T)
setwd("~/Hawaii 2018:BIOS 2018/RAnalysis")
main<-getwd()
library(seacarb) #used to calculate TA
library(tidyverse)
path<-"Data/20180617" #the location of all your titration files
massfile<-"20180617mass_Run2.csv" # name of your file with masses
titrationfile<-'20180617_Run2.csv'# name of the last titration file run
date<-'20180617'
Mass<-read.csv(file.path(path,massfile), header=T, sep=",", na.string="NA", as.is=T)
pHCal<-read.csv('Data/pHCalibration.csv') # read in the pH Calibration file
pHData<-pHCal[pHCal$Date==date,]
mod.pH<-lm(c(pHData$pH4, pHData$pH7, pHData$pH10)~c(4,7,10)) # linear model
plot(c(4,7,10), c(pHData$pH4, pHData$pH7, pHData$pH10), xlab = 'pH', ylab = 'mv')
lines(c(4,7,10), predict(mod.pH))
R2<-summary(mod.pH)$r.squared
legend('topright', legend = bquote(R^2 == .(format(R2, digits = 3))), bty='n')
pH35<-mod.pH$coefficients[1]+mod.pH$coefficients[2]*3.5
pH3<-mod.pH$coefficients[1]+mod.pH$coefficients[2]*3
nrows<-nrow(Mass) # number of rows in a mass file
TA <- data.frame(matrix(nrow = nrows, ncol = 5))
rownames(TA)<-Mass$Sample.ID1[1:nrows]
colnames(TA)<-c("Sample.ID",'TA','Mass', "Tank", "Type")
filename<-file.path(path,titrationfile)
AllData<-read.csv(filename, sep=",", na.string="NA",as.is=T, skip=8)[ ,1:5]
AllData <- AllData[-1,]
sample_name_positions <- c(1,grep("^0", AllData[,1]), nrow(AllData))
sample_name_positions <- sample_name_positions[-1] #remove first report of duplicated 1
sample_names<-Mass$sample
sample_names_list <- list()
for (item in 1:length(sample_names)){
sample_names_list[[item]] <- sample_names[item]
}
for (i in 1:nrows){
sample_names_list[[i]]<-data.frame(AllData[sample_name_positions[i]:sample_name_positions[i+1],])
colnames(sample_names_list[[i]])<-c("Time","Volume","mV", "dV/dt",	"Temperature")
}
for(i in 1:nrows) {
#  Data<-read.csv(file.names[i], header=F, sep=",", na.string="NA",as.is=T, skip=10)[ ,1:5]
# colnames(Data) <-  c("Volume","Time",	"mV",	"Temperature",	"dV/dt")
Data<-sample_names_list[[i]]
# everything was brought in as a character because of the second line, converts back to numeric
Data$mV<-suppressWarnings(as.numeric(Data$mV)) ## supress the warnings since NA will be produced through coercion
Data$Temperature<-suppressWarnings(as.numeric(Data$Temperature)) ## supress the warnings since NA will be produced through coercion
Data$Volume<-suppressWarnings(as.numeric(Data$Volume)) ## supress the warnings since NA will be produced through coercion
#name of the file without .csv
#name<-unlist(strsplit(file.names[i], split='.', fixed=TRUE))[1]
name<-sample_names[i]
#calculates the index of values between pH 2 and 3.5
mV<-which(Data$mV<pH3 & Data$mV>pH35)
#CHANGE ONLY WHEN NEW BOTTLE OF ACID IS USED----------------------------------
#Bottle A3 - acid titrant# ,
#density of your titrant: change every time acid is changed
d<-(-0.00000335*mean(Data$Temperature[mV], na.rm=T)^2-0.0001356*mean(Data$Temperature[mV], na.rm=T)+1.02613) #bottle changed 20180528
#20180529 batch A3
#concentration of your titrant: CHANGE EVERYTIME ACID IS CHANGED
c<-0.099793 #20180529 batch A3
#------------------------------------------------------------------------------
#Salinity of your samples
s<-Mass[Mass$sample==name,3]
#s<-Mass[name,2]
#mass of sample in g: changed with every sample
#mass<-Mass[name,1]
mass<-Mass[Mass$sample==name,2]
sample.id<-Mass[Mass$sample==name,4]
sample.type<-Mass[Mass$sample==name,5]
#sample.index<-Mass[Mass$Sample.ID1==name,3]# this is the order that the sample was run
#-------------------------------------------------------------------
#Calculate TA
#at function is based on code in seacarb package by Steeve Comeau, Heloise Lavigne and Jean-Pierre Gattuso
TA[i,1]<-name
TA[i,2]<-1000000*at(S=s,T=mean(Data$Temperature[mV], na.rm=T), C=c, d=d, pHTris=NULL, ETris=NULL, weight=mass, E=Data$mV[mV], volume=Data$Volume[mV])
TA[i,3]<-mass
TA[i,4]<-sample.id
TA[i,5]<-sample.type
}
TA[,2:3]<-sapply(TA[,2:3], as.numeric) # make sure the appropriate columns are numeric
write.table(TA,paste0(path,"/",date,"_TA_Output",".csv"),sep=",", row.names=FALSE)
cumu.data <- read.csv("Data/Cumulative_TA_Output.csv", header=TRUE, sep=",")
TA[i,1]<-name
TA[i,2]<-1000000*at(S=s,T=mean(Data$Temperature[mV], na.rm=T), C=c, d=d, pHTris=NULL, ETris=NULL, weight=mass, E=Data$mV[mV], volume=Data$Volume[mV])
#at function is based on code in seacarb package by Steeve Comeau, Heloise Lavigne and Jean-Pierre Gattuso
TA[i,1]<-name
TA[i,2]<-1000000*at(S=s,T=mean(Data$Temperature[mV], na.rm=T), C=c, d=d, pHTris=NULL, ETris=NULL, weight=mass, E=Data$mV[mV], volume=Data$Volume[mV])
TA[i,3]<-mass
TA[i,4]<-sample.id
TA[i,5]<-sample.type
}
TA[,2:3]<-sapply(TA[,2:3], as.numeric) # make sure the appropriate columns are numeric
#exports your data as a CSV file
write.table(TA,paste0(path,"/",date,"_TA_Output",".csv"),sep=",", row.names=FALSE)
cumu.data <- read.csv("Data/Cumulative_TA_Output.csv", header=TRUE, sep=",")
update.data <- rbind(cumu.data, TA)
write.table(update.data,"Data/Cumulative_TA_Output.csv",sep=",", row.names=FALSE)
pHCal<-read.csv('Data/pHCalibration.csv') # read in the pH Calibration file
pHCal
pHData<-pHCal[pHCal$Date==date,]
pHData
mod.pH<-lm(c(pHData$pH4, pHData$pH7, pHData$pH10)~c(4,7,10)) # linear model
mod.pH
plot(c(4,7,10), c(pHData$pH4, pHData$pH7, pHData$pH10), xlab = 'pH', ylab = 'mv')
lines(c(4,7,10), predict(mod.pH))
R2<-summary(mod.pH)$r.squared
legend('topright', legend = bquote(R^2 == .(format(R2, digits = 3))), bty='n')
pH35<-mod.pH$coefficients[1]+mod.pH$coefficients[2]*3.5
pH3<-mod.pH$coefficients[1]+mod.pH$coefficients[2]*3
nrows<-nrow(Mass) # number of rows in a mass file
TA <- data.frame(matrix(nrow = nrows, ncol = 5))
rownames(TA)<-Mass$Sample.ID1[1:nrows]
colnames(TA)<-c("Sample.ID",'TA','Mass', "Tank", "Type")
TA
#run a for loop to bring in the titration files one at a time and calculate TA
# read in the mega concatenated titration results file
filename<-file.path(path,titrationfile)
AllData<-read.csv(filename, sep=",", na.string="NA",as.is=T, skip=8)[ ,1:5]
AllData <- AllData[-1,]
# Identifies rows starting with zero seconds "0" in column 1
sample_name_positions <- c(1,grep("^0", AllData[,1]), nrow(AllData))
sample_name_positions <- sample_name_positions[-1] #remove first report of duplicated 1
## parse through all the data in the one file ###
sample_names<-Mass$sample
# create a list with all the sample IDs
sample_names_list <- list()
for (item in 1:length(sample_names)){
sample_names_list[[item]] <- sample_names[item]
}
# fill the list with the data from each sample
for (i in 1:nrows){
sample_names_list[[i]]<-data.frame(AllData[sample_name_positions[i]:sample_name_positions[i+1],])
colnames(sample_names_list[[i]])<-c("Time","Volume","mV", "dV/dt",	"Temperature")
}
for(i in 1:nrows) {
#  Data<-read.csv(file.names[i], header=F, sep=",", na.string="NA",as.is=T, skip=10)[ ,1:5]
# colnames(Data) <-  c("Volume","Time",	"mV",	"Temperature",	"dV/dt")
Data<-sample_names_list[[i]]
# everything was brought in as a character because of the second line, converts back to numeric
Data$mV<-suppressWarnings(as.numeric(Data$mV)) ## supress the warnings since NA will be produced through coercion
Data$Temperature<-suppressWarnings(as.numeric(Data$Temperature)) ## supress the warnings since NA will be produced through coercion
Data$Volume<-suppressWarnings(as.numeric(Data$Volume)) ## supress the warnings since NA will be produced through coercion
#name of the file without .csv
#name<-unlist(strsplit(file.names[i], split='.', fixed=TRUE))[1]
name<-sample_names[i]
#calculates the index of values between pH 2 and 3.5
mV<-which(Data$mV<pH3 & Data$mV>pH35)
d<-(-0.00000335*mean(Data$Temperature[mV], na.rm=T)^2-0.0001356*mean(Data$Temperature[mV], na.rm=T)+1.02613) #bottle changed 20180528
c<-0.099793 #20180529 batch A3
s<-Mass[Mass$sample==name,3]
mass<-Mass[Mass$sample==name,2]
sample.id<-Mass[Mass$sample==name,4]
sample.type<-Mass[Mass$sample==name,5]
TA[i,1]<-name
TA[i,2]<-1000000*at(S=s,T=mean(Data$Temperature[mV], na.rm=T), C=c, d=d, pHTris=NULL, ETris=NULL, weight=mass, E=Data$mV[mV], volume=Data$Volume[mV])
TA[i,3]<-mass
TA[i,4]<-sample.id
TA[i,5]<-sample.type
for(i in 1:nrows) {
#  Data<-read.csv(file.names[i], header=F, sep=",", na.string="NA",as.is=T, skip=10)[ ,1:5]
# colnames(Data) <-  c("Volume","Time",	"mV",	"Temperature",	"dV/dt")
Data<-sample_names_list[[i]]
# everything was brought in as a character because of the second line, converts back to numeric
Data$mV<-suppressWarnings(as.numeric(Data$mV)) ## supress the warnings since NA will be produced through coercion
Data$Temperature<-suppressWarnings(as.numeric(Data$Temperature)) ## supress the warnings since NA will be produced through coercion
Data$Volume<-suppressWarnings(as.numeric(Data$Volume)) ## supress the warnings since NA will be produced through coercion
#name of the file without .csv
#name<-unlist(strsplit(file.names[i], split='.', fixed=TRUE))[1]
name<-sample_names[i]
#calculates the index of values between pH 2 and 3.5
mV<-which(Data$mV<pH3 & Data$mV>pH35)
#CHANGE ONLY WHEN NEW BOTTLE OF ACID IS USED----------------------------------
#Bottle A3 - acid titrant# ,
#density of your titrant: change every time acid is changed
d<-(-0.00000335*mean(Data$Temperature[mV], na.rm=T)^2-0.0001356*mean(Data$Temperature[mV], na.rm=T)+1.02613) #bottle changed 20180528
#20180529 batch A3
#concentration of your titrant: CHANGE EVERYTIME ACID IS CHANGED
c<-0.099793 #20180529 batch A3
#------------------------------------------------------------------------------
#Salinity of your samples
s<-Mass[Mass$sample==name,3]
#s<-Mass[name,2]
#mass of sample in g: changed with every sample
#mass<-Mass[name,1]
mass<-Mass[Mass$sample==name,2]
sample.id<-Mass[Mass$sample==name,4]
sample.type<-Mass[Mass$sample==name,5]
#sample.index<-Mass[Mass$Sample.ID1==name,3]# this is the order that the sample was run
#-------------------------------------------------------------------
#Calculate TA
#at function is based on code in seacarb package by Steeve Comeau, Heloise Lavigne and Jean-Pierre Gattuso
TA[i,1]<-name
TA[i,2]<-1000000*at(S=s,T=mean(Data$Temperature[mV], na.rm=T), C=c, d=d, pHTris=NULL, ETris=NULL, weight=mass, E=Data$mV[mV], volume=Data$Volume[mV])
TA[i,3]<-mass
TA[i,4]<-sample.id
TA[i,5]<-sample.type
}
TA[,2:3]<-sapply(TA[,2:3], as.numeric) # make sure the appropriate columns are numeric
write.table(TA,paste0(path,"/",date,"_TA_Output",".csv"),sep=",", row.names=FALSE)
cumu.data <- read.csv("Data/Cumulative_TA_Output.csv", header=TRUE, sep=",")
update.data <- rbind(cumu.data, TA)
write.table(update.data,"Data/Cumulative_TA_Output.csv",sep=",", row.names=FALSE)
# fill the list with the data from each sample
for (i in 1:nrows){
sample_names_list[[i]]<-data.frame(AllData[sample_name_positions[i]:sample_name_positions[i+1],])
colnames(sample_names_list[[i]])<-c("Time","Volume","mV", "dV/dt",	"Temperature")
}
for(i in 1:nrows) {
#  Data<-read.csv(file.names[i], header=F, sep=",", na.string="NA",as.is=T, skip=10)[ ,1:5]
# colnames(Data) <-  c("Volume","Time",	"mV",	"Temperature",	"dV/dt")
Data<-sample_names_list[[i]]
# everything was brought in as a character because of the second line, converts back to numeric
Data$mV<-suppressWarnings(as.numeric(Data$mV)) ## supress the warnings since NA will be produced through coercion
Data$Temperature<-suppressWarnings(as.numeric(Data$Temperature)) ## supress the warnings since NA will be produced through coercion
Data$Volume<-suppressWarnings(as.numeric(Data$Volume)) ## supress the warnings since NA will be produced through coercion
#name of the file without .csv
#name<-unlist(strsplit(file.names[i], split='.', fixed=TRUE))[1]
name<-sample_names[i]
#calculates the index of values between pH 2 and 3.5
mV<-which(Data$mV<pH3 & Data$mV>pH35)
#CHANGE ONLY WHEN NEW BOTTLE OF ACID IS USED----------------------------------
#Bottle A3 - acid titrant# ,
#density of your titrant: change every time acid is changed
d<-(-0.00000335*mean(Data$Temperature[mV], na.rm=T)^2-0.0001356*mean(Data$Temperature[mV], na.rm=T)+1.02613) #bottle changed 20180528
#20180529 batch A3
#concentration of your titrant: CHANGE EVERYTIME ACID IS CHANGED
c<-0.099793 #20180529 batch A3
#------------------------------------------------------------------------------
#Salinity of your samples
s<-Mass[Mass$sample==name,3]
#s<-Mass[name,2]
#mass of sample in g: changed with every sample
#mass<-Mass[name,1]
mass<-Mass[Mass$sample==name,2]
sample.id<-Mass[Mass$sample==name,4]
sample.type<-Mass[Mass$sample==name,5]
#sample.index<-Mass[Mass$Sample.ID1==name,3]# this is the order that the sample was run
#-------------------------------------------------------------------
#Calculate TA
#at function is based on code in seacarb package by Steeve Comeau, Heloise Lavigne and Jean-Pierre Gattuso
TA[i,1]<-name
TA[i,2]<-1000000*at(S=s,T=mean(Data$Temperature[mV], na.rm=T), C=c, d=d, pHTris=NULL, ETris=NULL, weight=mass, E=Data$mV[mV], volume=Data$Volume[mV])
TA[i,3]<-mass
TA[i,4]<-sample.id
TA[i,5]<-sample.type
}
rm(list=ls())
main<-getwd()
library(seacarb) #used to calculate TA
library(tidyverse)
path<-"Data/20180617" #the location of all your titration files
massfile<-"20180617mass_Run2.csv" # name of your file with masses
titrationfile<-'20180617_Run2.csv'# name of the last titration file run
date<-'20180617'
Mass<-read.csv(file.path(path,massfile), header=T, sep=",", na.string="NA", as.is=T)
pHCal<-read.csv('Data/pHCalibration.csv') # read in the pH Calibration file
pHData<-pHCal[pHCal$Date==date,]
mod.pH<-lm(c(pHData$pH4, pHData$pH7, pHData$pH10)~c(4,7,10)) # linear model
plot(c(4,7,10), c(pHData$pH4, pHData$pH7, pHData$pH10), xlab = 'pH', ylab = 'mv')
lines(c(4,7,10), predict(mod.pH))
R2<-summary(mod.pH)$r.squared
legend('topright', legend = bquote(R^2 == .(format(R2, digits = 3))), bty='n')
pH35<-mod.pH$coefficients[1]+mod.pH$coefficients[2]*3.5
pH3<-mod.pH$coefficients[1]+mod.pH$coefficients[2]*3
nrows<-nrow(Mass) # number of rows in a mass file
TA <- data.frame(matrix(nrow = nrows, ncol = 5))
rownames(TA)<-Mass$Sample.ID1[1:nrows]
colnames(TA)<-c("Sample.ID",'TA','Mass', "Tank", "Type")
filename<-file.path(path,titrationfile)
AllData<-read.csv(filename, sep=",", na.string="NA",as.is=T, skip=8)[ ,1:5]
AllData <- AllData[-1,]
sample_name_positions <- c(1,grep("^0", AllData[,1]), nrow(AllData))
sample_name_positions <- sample_name_positions[-1] #remove first report of duplicated 1
sample_names<-Mass$sample
sample_names_list <- list()
for (item in 1:length(sample_names)){
sample_names_list[[item]] <- sample_names[item]
}
for (i in 1:nrows){
sample_names_list[[i]]<-data.frame(AllData[sample_name_positions[i]:sample_name_positions[i+1],])
colnames(sample_names_list[[i]])<-c("Time","Volume","mV", "dV/dt",	"Temperature")
}
for(i in 1:nrows) {
#  Data<-read.csv(file.names[i], header=F, sep=",", na.string="NA",as.is=T, skip=10)[ ,1:5]
# colnames(Data) <-  c("Volume","Time",	"mV",	"Temperature",	"dV/dt")
Data<-sample_names_list[[i]]
# everything was brought in as a character because of the second line, converts back to numeric
Data$mV<-suppressWarnings(as.numeric(Data$mV)) ## supress the warnings since NA will be produced through coercion
Data$Temperature<-suppressWarnings(as.numeric(Data$Temperature)) ## supress the warnings since NA will be produced through coercion
Data$Volume<-suppressWarnings(as.numeric(Data$Volume)) ## supress the warnings since NA will be produced through coercion
#name of the file without .csv
#name<-unlist(strsplit(file.names[i], split='.', fixed=TRUE))[1]
name<-sample_names[i]
#calculates the index of values between pH 2 and 3.5
mV<-which(Data$mV<pH3 & Data$mV>pH35)
#CHANGE ONLY WHEN NEW BOTTLE OF ACID IS USED----------------------------------
#Bottle A3 - acid titrant# ,
#density of your titrant: change every time acid is changed
d<-(-0.00000335*mean(Data$Temperature[mV], na.rm=T)^2-0.0001356*mean(Data$Temperature[mV], na.rm=T)+1.02613) #bottle changed 20180528
#20180529 batch A3
#concentration of your titrant: CHANGE EVERYTIME ACID IS CHANGED
c<-0.099793 #20180529 batch A3
#------------------------------------------------------------------------------
#Salinity of your samples
s<-Mass[Mass$sample==name,3]
#s<-Mass[name,2]
#mass of sample in g: changed with every sample
#mass<-Mass[name,1]
mass<-Mass[Mass$sample==name,2]
sample.id<-Mass[Mass$sample==name,4]
sample.type<-Mass[Mass$sample==name,5]
#sample.index<-Mass[Mass$Sample.ID1==name,3]# this is the order that the sample was run
#-------------------------------------------------------------------
#Calculate TA
#at function is based on code in seacarb package by Steeve Comeau, Heloise Lavigne and Jean-Pierre Gattuso
TA[i,1]<-name
TA[i,2]<-1000000*at(S=s,T=mean(Data$Temperature[mV], na.rm=T), C=c, d=d, pHTris=NULL, ETris=NULL, weight=mass, E=Data$mV[mV], volume=Data$Volume[mV])
TA[i,3]<-mass
TA[i,4]<-sample.id
TA[i,5]<-sample.type
}
Mass
setwd("/Users/valerieschmidt/MyProjects/BioMin_HIS/RAnalysis/Data/pH_Calibration_Files") #set working directory
source('~/Downloads/Tris.calib.R')
source('~/MyProjects/BioMin_HIS/RAnalysis/Scripts/CarbChem.R')
rm(list=ls()) # removes all prior objects
source('~/MyProjects/BioMin_HIS/RAnalysis/Scripts/CarbChem.R')
